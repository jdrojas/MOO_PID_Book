\chapter{Introduction}
%\begin{refsection}
\label{sec:Antecedentes}
The design of control systems always has to consider multiple and possibly conflicting design objectives. From this perspective, the task of the engineer in charge of the control system, becomes to find the optimal point of compromise within this set of distinct objectives \citep{Garpinger2012}.

The most used control algorithm in industry is the \gls{pid}. This type of algorithm is used in a wide variety of applications, due to its limited number of parameters, its ease of implementation and its robustness \citep{astromhagglund2006} and represents an area of active study since the first tuning methodology was proposed in the 1940s \citep{Ziegler1942}.

It is common practice that the problem of tuning the parameters of industrial controllers is posed as an optimization problem. When all the objectives need to be taken into account at the same time, this problem becomes a multivariable, multiobjective optimization problem. In the particular case of industrial \gls{pid} controllers, this problem is also non-linear and (possibly) non convex, therefore, the problem at hand is not trivial.

Regardless of the methodology to be used, it is generally computationally expensive to solve a multiobjective optimization problem, which can lead to a scenario of multiple equally optimal solutions, so that in addition to solving the optimization problem, the control engineer, ends up with the extra responsibility of entering into a posteriori decision phase  to finally choose the best set of parameters for its specific application.

In this sense, \gls{moo} tuning of \gls{pid} controllers remains as an open research subject, even though it has bee studied for several decades. For example, in \citet{Seaman1994} a type of \gls{moo} is used to tune \gls{pid} controllers in a plastic injection molding process. In \citet{Abbas1995}, an algorithm based on several optimizations is proposed to find the optimal parameters of a \gls{pid} controller; this algorithm took into account several variables such as stationary error, rise time, overrun, settling time and maximum controller output within the feedback loop. More recently, bio-inspired techniques such as neural networks, fuzzy logic or genetic algorithms have been used to solve the optimization problem \citet{Reynoso-Meza2012b}. In \citet{Bagis2011}, A Tabu search algorithm is used to tune \gls{pid} controllers in real time, based in a set of closed loop specifications and a cost function. In \citet{Chiha2012} the \gls{moop} for \gls{pid} controllers is solved using the ant colony approach, this methodology tries to simulate the behavior of real ants when they are looking of the shortest path to a given objective.

Besides bio-inspired methods for \gls{moop}, there are several methodologies that transform the \gls{moop} into a single function optimization problem, by rewriting the problem with extra constrains. The simplest method is the \gls{ws} \citep{Marler2004}. With the \gls{ws} method, the multiobjective cost function is transformed into a one dimensional function using a weighted sum that gives a greater relative weight to a function in comparison to the others. For each set of weight values a different optimal solution is found for the same problem. The set of all solutions is part of the Pareto front \citep{Marler2004}. The Pareto front corresponds to all equally optimal solutions for a \gls{moop}. The problem with the \gls{ws} method is that, although the results obtained are from the Pareto front, it is not possible to satisfactorily construct the entire front \citep{Das1997,Messac2000,Marler2010}.

In order to obtain the Pareto front correctly, other methodologies have emerged that surpass the \gls{ws}. The \gls{nbi} method consist in rewriting the optimization problem so that the feasible area is shortened by an equality constraint that depends on an extra parameter \citep{Das1998}. The solution of this new problem will terminate at the Pareto border and by varying this extra parameter, it is possible to find the Pareto front so that each found point is equally spaced at the front. This feature is very useful since it gives an overall idea of the shape of the front. \gls{nbi} has been applied to the tuning of controllers in \citet{Gambier2009} where the controller is selected taking into account different performance indexes like the integral of the squared error (ISE), the integral time-weighted squared error (ITSE) and the integral of the squared time-weighted squared error (ISTSE). Other methodology similar to \gls{nbi} is the \gls{nnc} \citep{Messac2003}, which converts the \gls{moop} in a single function optimization with an extra inequality constraint.

It should be noted that these methodologies have also been used in other areas apart from the control of industrial processes. A few examples of the areas in which it has been applied are: calculation of optimal power flow in power systems \citep{Roman2006}  and distributed generation planning \citep{Zangeneh2007},  for the control of biochemical processes \citep{Logist2009}, circuit analysis \citep{Stehr2003}, development of optimal supply strategies for the participants of oligopolistic energy markets \citep{Vahidinasab2010}.

The objective of this book is to present the methodology to tune \gls{pid} controllers as a \gls{moo} problem. Along the book, several industrial examples are taken into account to exemplify the concepts and gain insight into the application. With some sections of the book, a companion software written on \matlab is included. The idea with the software is to be as open as possible, the reader will be able not only to have access to the code, but also to the data base that was obtained while solving the \gls{moop}.

In Chapter~\ref{chap:IndustrialPID} the fundamental concepts of process control are presented to set the basic foundations of this book. An Isothermal Continuously Stirred Tank Reactor is used as example to explain the methodology that is employed within the control field. In Chapter~\ref{chap:PIDControllerConsideration} the metrics used for performance and robustness are presented for the case of \gls{pid} control along with the tradeoffs that arises in a controlled system are considered, for example the well known relationship between servo and regulation responses, or between performance and robustness.

Chapter~\ref{chap:PIDControllerDesign} presents the foundation of \gls{pid} tuning, first the analytical tuning methods are presented in order to have the most fundamental mathematical description of a tuning rule. Then, the tuning based on the minimization of a performance criteria is considered. This subject is important for this particular book because the methodology that is presented is based on the minimization of multiple cost functions at the same time.

From Chapter~\ref{chap:Multi-objective} until the end of the book, the multiobjective case is considered. Particularly in this chapter, the basic formulation of the optimization problem is presented with the introduction of the Pareto front concept. The methodology chosen to solve the multiobjective optimization problem is to transform the multi-criteria situation into a single scalar cost function. A wastewater treatment plant model is used as example on how the Pareto can be applied to industrial processes.

The \gls{moo} techniques are tested and applied to different scenarios in Chapter~\ref{chap:ApplicationExamplesNoGUI}. Different scalarization techniques are tested and the methodology is applied to a LiTaO$_3$ Thin Film Deposition Process. In Chapter~\ref{chap:PIDMOOP}, the \gls{pid} tuning problem stated in Chapter~\ref{chap:PIDControllerDesign} is solved using the ENNC methodology presented in Chapter~\ref{chap:Multi-objective}. First the problem is solved using a \matlab{} script that can be found in the appendix of this chapter and also downloaded as a companion software. The result of this script is a set of files that defines 2200 Pareto fronts with the optimal solutions of the problem of finding the tuning of \gls{2dof} \gls{pid} controller for \gls{soptd} plant families. Then two possible approaches are presented to use this results: first an attempt to find a tuning rule based on this data is presented. This approach was found to be very difficult to apply given the complexity of the data. Then the data was used as a data base and a GUI was created to serve as the bridge between the user and the results. This GUI was encapsulated as a MATLAB app and included as the companion software for this book.

Finally, in Chapter~\ref{chap:ApplicationExamples} different examples are provided to exemplify the application of the tool presented in this book. The software is used to analyze the temperature control in a Continuously Stirred Tank Heater and the concentration of the product in an isothermal Continuously Stirred Tank Reactor.

\bibliographystyle{spbasic}
\bibliography{ReferenciasMulti}